---Topic 1. util/formatter.---

1. Format. Дополнить класс Person внутренним enum (формат) с константами SHORT, MEDIUM, LONG
и возможностью печатать Person в указанный PrintStream (например System.out или System.err),
в указанном (одном из трех) формате. Выводимые поля и их конечный формат выберите на свое усмотрение.
Дата рождения человека должна выводится в принятом у нас формате (в нашей локале).

2. Format. Дополнить класс Person реализацией ин-фейса Formattable для вывода через %s.

[3. Format. При форматировании учитывать FormattableFlags.


---Topic 2. Byte IO Streams.---

1. RandomInputStream extends InputStream. Реализовать класс по генерации случайных байт в виде байтового потока
длиною не меньше MIN_LENGTH, но не более MAX_LENGTH (это такие константы, значения придумайте сами, размер потока
возвращаемый available(), лежит в этих промежутках).

2.* Добавить поддержку markSupported().

3.* CaesarCipherStream. Написать классы-потоки изменяющие нижележащий поток байт прибавляя к каждому байту некоторое
число shift в соответствии с Шифром Цезаря. Классы наследовать от FilterInputStream и FilterOutputStream.

CaesarCipherStream.java
    -CaesarInputStream
    -CaesarOutputStream
    -Demo


---Topic 3. Generics.---

1.pro/generics/dynamic-array. Дано: generic array T[] and T element. Написать статический метод для подсчета количества
элементов в массиве меньших чем данный элемент. Будет ли тип T типом возвращаемого значения метода?

2.pro/generics/dynamic-array. Дополнить Array. Написать метод, который принимает коллекцию чисел, возвращает
отсортированный список чисел из каждого элемента которого вычли число, соответствующее среднему арифметическому
младших 16 разрядов элементов исходной collection. Соблюдать контроль типов на этапе компиляции. Исходная коллекция
должна состоять только из сравниваемых элементов типа: AtomicInteger, AtomicLong, BigDecimal, BigInteger, Byte, Double,
DoubleAccumulator, DoubleAdder,Float, Integer, Long, LongAccumulator, LongAdder, Short или наследника какого-либо
вышеперечисленных классов.

3.pro/generics/wild-department. Следуя DRY разработать Department на основе Array, содержащий информацию о сотрудниках.
Employee extends Person; Дополнить Department свойством String name и методом double averageAge() и boolean
hasSameAverageAge(..., double epsilon) принимающий другой департамент. Использовать Wildcard.

4.pro/generics/num-array. На основе предыдущей версии Array разработать NumArray. Предоставить возможность сериализации и десериализации
динамического массива состоящего в частности из элементов LazyBigInteger (extends java.math.BigInteger)
который в качестве элементов содержит java.util.function.LongSupplier(Not Serializable).
Вывести на экран List<LazyBigInteger> десериализированный из потока байт, который изначально состоял из 5 случайных
элементов.


---Topic 4. Collections.---

1. TryingOutList. Работа с ArrayList через интерфейс List.
Написать свой метод  asList(..) для конвертации массива строк, чисел в список.
Написать метод printRm(..), который создаст список (List) чисел, положит в него
10 элементов, затем удалит первые 3 и последний, а затем выведет результат на экран.

2. QueueWrapper. Написать метод  asList(..) который принимает очередь любых generic элементов Queue,
но возвращает список List, при этом изменения вносимые в изначальную очередь отражаются на полученном списке.
Например, при удалении элемента из очереди, размер списка должен уменьшится на 1.

3. SetMath. Напишите класс с методами принимающими два множества
и возвращающими другое множество в соответствии с изображением.
    (*(*)*)  Union/Союз
    ( (*) )  Intersection/В точке пересечения
    (*( )*)  Difference/Разница

4. Iterators. Написать метод  filter(..) который принимает множество Person и параметр возраст.
Возвращает новое множество, содержащее только людей равных и старше указанного возраста. Продемонстрировать использование.

5. Translator. Написать программу переводчик, которая будет переводить текст, написанный на одном языке,
на другой язык согласно заранее составленному словарю.

6. N. Реализовывать итератор во всех своих коллекциях.
Сделать список из трех элементов. Получить итератор.
a) удалить первый и последний элемент через ссылку на коллекцию;
b) закоментировать предыдущий вариант, реализовать a) через ссылку на итератор;
c) вывести коллекцию через итератор;
d) вывести в обратном порядке;
e) сгенерировать random длину [5; 15], заполнить random целыми элементами;
    среднесеметричному элементу установить значение макс. элемента, а затертый среднесеметричный добавить
с помощью итератора методом add();

7. HashMapDemo. Добавить пару пар (K, V).
a) При итерировании по entrySet сделать в Map перевод значений на English language с entrySetValue.
    if Человек1 -> Human1;
b) Проитерироваться по коллекции значений и поудалять все пустые значения == null;

8. Реализовать свою имплементация коллекций:
collections/TryingOutList
collections/QueueWrapper
collections/SetMath
collections/Iterators
collections/Translator

collections/my/*
MyArrayQueue
MyLinkedStack
MyBoundedLinkedList
MyArrayPriorityQueue

MyCopyOnWriteArraySet
MyHashMap
MySynchronizedHashSet

MyNavigableMultiMap
MyTreeMap
MyTreeSet


---Topic 5. Multithreading.---

1. threads/nosynch/A.txt
    1. Безопасно ли вызывать операцию i++ из разных потоков одновременно? Насколько эта операция атомарна и почему?
    2. Установите опытным путем приблизительную вероятность верного ответа для программы SwapperDemo.
    3. [Предложите идею на концептуальном/принципиальном уровне как необходимо исправить проект Shop или прект Bank,
    чтобы программа работала корректно во всех случаях. Какой минимальный участок кода программы должен выполнятся
    как атомарная операция?]

2. Скопируйте проект Shop или проект Bank. Исправте ошибки многопоточного проектирования правильно применив блокировки
таким образом, чтобы программа гарантированно выдавала всегда верный результат.

3. threads/conditions/
    1. Для проекта Bank реализовать MoneyLifeDemo по циклическому пополнению аккаунта из одного потока
    и циклическому снятию средств из другого. Чередовать вывод на консоль диагностических сообщений
    с небольшой задержкой Thread.sleep(..).
    2. Скопировать и модифицировать MoneyLifeDemo:3 потока снимающих деньги,1 поток пополняющий. Применить блокировки.
    3. Скопировать и модифицировать MoneyLifeDemo: применить условные переменные (имя должно отражать состояние,
    например: isEmpty, isFull, sufficientBytes, bufferChanged, dataArrived). Поток снимающий деньги со счета,
    не должен производить отрицательный баланс, вместо этого поток должен переходить в состояние WAITING и ожидать
    поступления новых средств. Поток, пополняющий счет, не должен производить пополнение если деньги на счету
    "не упали ниже критичекого уровня". Уровень определить по собственному усмотрению.

4. Synchronized. Скопировать и модифицировать ранее написанный код применяющий блокировки java.util.cuncurrent
на более коипактный способ с применением ключевого слова synchronized.